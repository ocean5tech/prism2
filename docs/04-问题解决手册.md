# 04-问题解决手册

> **基于实际遇到问题的解决方案汇总**
>
> 从LessonsLearned.md和开发过程中总结的关键问题及解决方案

## 🚫 代理配置问题

### 问题1: 公司代理阻止localhost访问
**现象**: API调用返回403 Forbidden，curl localhost失败
```bash
curl: (7) Failed to connect to localhost port 8001
HTTP 403 Forbidden
```

**根本原因**: 公司代理设置影响本地服务间通信

**永久解决方案**:
```bash
# 1. 环境变量配置 (所有终端)
export no_proxy="localhost,127.0.0.1,::1,0.0.0.0"
export NO_PROXY="localhost,127.0.0.1,::1,0.0.0.0"

# 2. 添加到 ~/.bashrc
echo 'export no_proxy="localhost,127.0.0.1,::1,0.0.0.0"' >> ~/.bashrc
echo 'export NO_PROXY="localhost,127.0.0.1,::1,0.0.0.0"' >> ~/.bashrc

# 3. Docker Compose配置
environment:
  - no_proxy=localhost,127.0.0.1,::1,0.0.0.0
  - NO_PROXY=localhost,127.0.0.1,::1,0.0.0.0

# 4. 验证配置
curl -v http://localhost:8001/health
```

### 问题2: Pydantic验证错误 - extra_forbidden
**现象**: `Extra inputs are not permitted [type=extra_forbidden, input_value='localhost,127.0.0.1,::1']`

**解决方案**: 从Pydantic模型中排除代理相关环境变量
```python
# app/core/config.py
class Settings(BaseSettings):
    # 业务配置
    database_url: str
    redis_url: str

    class Config:
        env_file = ".env"
        # 忽略代理相关变量
        extra = "ignore"
```

## 🗄️ 数据库连接问题

### 问题3: PostgreSQL认证失败
**现象**: `password authentication failed for user 'postgres'`

**诊断步骤**:
```bash
# 1. 检查容器状态
docker ps | grep postgres

# 2. 检查环境变量
docker exec prism2-postgres env | grep POSTGRES

# 3. 测试连接
docker exec prism2-postgres pg_isready -U prism2
```

**解决方案**:
```bash
# 确保环境变量正确
DATABASE_URL=postgresql://prism2:prism2_secure_password@localhost:5432/prism2

# 重置容器
docker-compose down postgres
docker volume rm prism2_postgres_data
docker-compose up -d postgres
```

### 问题4: 数据库连接池耗尽
**现象**: `QueuePool limit of size 20 overflow 30 reached`

**解决方案**: 优化连接池配置
```python
from sqlalchemy import create_engine

engine = create_engine(
    DATABASE_URL,
    pool_size=20,           # 基础连接数
    max_overflow=30,        # 额外连接数
    pool_timeout=30,        # 连接超时
    pool_recycle=3600,      # 连接回收时间
    pool_pre_ping=True      # 连接验证
)
```

## 🔗 向量数据库问题

### 问题5: ChromaDB容器启动失败和连接问题

#### 5.1 ChromaDB API返回403 Forbidden
**现象**:
```bash
curl http://localhost:8000/api/v1/heartbeat
# 返回: HTTP/1.0 403 Forbidden
```

**根本原因**: 容器启动时继承宿主机代理环境变量，导致内部网络被拦截

**Docker Compose解决方案**:
```yaml
# docker-compose.yml中ChromaDB配置
chromadb:
  image: chromadb/chroma:latest
  environment:
    - CHROMA_SERVER_HOST=0.0.0.0
    - CHROMA_SERVER_HTTP_PORT=8000
    - PERSIST_DIRECTORY=/chroma/chroma
    # 明确清除代理设置
    - http_proxy=
    - https_proxy=
    - HTTP_PROXY=
    - HTTPS_PROXY=
  volumes:
    - chromadb_data:/chroma/chroma
```

#### 5.2 ChromaDB连接冲突 (应用层)
**现象**: `An instance of Chroma already exists for localhost:8000 with different settings`

**解决方案**: 实现正确的单例模式 + Docker服务发现
```python
class VectorService:
    _instance = None
    _initialized = False

    def __new__(cls):
        if cls._instance is None:
            cls._instance = super().__new__(cls)
        return cls._instance

    def __init__(self):
        if not self._initialized:
            # 使用Docker服务名而非localhost
            self.client = chromadb.HttpClient(
                host=os.getenv("CHROMADB_HOST", "chromadb"),
                port=int(os.getenv("CHROMADB_PORT", "8000")),
                settings=Settings(allow_reset=True)
            )
            self._initialized = True
```

#### 5.3 ChromaDB依赖问题 (旧版本问题)
**现象**: 本地安装chromadb时各种依赖冲突

**Docker优势**:
- ✅ 官方镜像包含所有依赖
- ✅ 版本锁定，无冲突
- ✅ 隔离环境，不影响宿主机
- ✅ 一键启动，无需复杂配置

**验证命令**:
```bash
# 检查ChromaDB容器状态
docker-compose ps chromadb

# 测试API连接
curl http://localhost:8000/api/v1/heartbeat

# 查看容器日志
docker-compose logs chromadb
```

### 问题6: UUID字段验证错误
**现象**: `Input should be a valid string [type=string_type, input_value=UUID(...)]`

**解决方案**: 正确处理UUID类型转换
```python
# API响应中转换UUID为字符串
response_data = {
    "task_id": str(task.task_id),  # UUID -> str
    "status": task.status
}

# 数据库查询中使用UUID类型
task = session.query(BootstrapTask).filter(
    BootstrapTask.task_id == uuid.UUID(task_id)
).first()
```

## 📦 依赖管理问题

### 问题7: AKShare依赖缺失
**现象**: `ModuleNotFoundError: No module named 'akshare'`

**解决方案**: 添加到requirements.txt
```txt
# requirements.txt 新增
akshare>=1.12.0
pandas>=2.0.0
requests>=2.31.0
```

### 问题8: 包版本冲突
**现象**: 不同包要求不兼容的依赖版本

**解决方案**: 使用兼容版本范围
```txt
# 使用兼容性范围而非固定版本
fastapi>=0.104.0,<0.105.0
uvicorn>=0.24.0,<0.25.0
pydantic>=2.5.0,<2.6.0
```

## 🌐 API服务问题

### 问题9: 外部API请求失败
**现象**: RSS源返回403或超时

**诊断和解决**:
```python
# 1. 测试API可用性
import requests

def test_data_sources():
    sources = {
        "新浪财经RSS": "http://rss.sina.com.cn/roll/finance/hot_roll.xml",
        "同花顺财经": "https://news.10jqka.com.cn/rss_info.php"
    }

    for name, url in sources.items():
        try:
            response = requests.get(url, timeout=10)
            print(f"✅ {name}: {response.status_code}")
        except Exception as e:
            print(f"❌ {name}: {e}")

# 2. 结果: 只有新浪财经可用，其他已失效
# 3. 更新数据源配置，移除失效源
```

### 问题10: WebSocket连接断开
**现象**: 前端WebSocket频繁断开重连

**解决方案**: 配置Nginx WebSocket代理
```nginx
location /ws/ {
    proxy_pass http://backend;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection "upgrade";
    proxy_set_header Host $host;
    proxy_cache_bypass $http_upgrade;
}
```

## 🔄 批处理任务问题

### 问题11: 夜间任务内存泄漏
**现象**: 长时间运行后内存使用持续增长

**解决方案**: 实现内存管理
```python
import gc
import psutil

def monitor_memory():
    process = psutil.Process()
    memory_mb = process.memory_info().rss / 1024 / 1024
    if memory_mb > 1024:  # 超过1GB
        gc.collect()  # 强制垃圾回收
        print(f"Memory: {memory_mb:.2f}MB, GC triggered")

# 在循环处理中调用
for batch in data_batches:
    process_batch(batch)
    monitor_memory()
```

### 问题12: API限流问题
**现象**: AKShare API返回429 Too Many Requests

**解决方案**: 实现智能限流
```python
import time
from functools import wraps

def rate_limit(calls_per_minute=60):
    def decorator(func):
        last_called = [0.0]

        @wraps(func)
        def wrapper(*args, **kwargs):
            elapsed = time.time() - last_called[0]
            wait_time = 60.0 / calls_per_minute

            if elapsed < wait_time:
                time.sleep(wait_time - elapsed)

            last_called[0] = time.time()
            return func(*args, **kwargs)

        return wrapper
    return decorator

@rate_limit(calls_per_minute=30)  # AKShare限制
def get_stock_data(code):
    return ak.stock_zh_a_hist(symbol=code)
```

## 🐳 Docker部署问题

### 问题13: 容器启动顺序依赖
**现象**: 应用服务在数据库未就绪时启动失败

**解决方案**: 使用健康检查和依赖等待
```yaml
services:
  backend:
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
```

### 问题14: 数据卷权限问题
**现象**: `Permission denied` 访问挂载的数据目录

**解决方案**: 设置正确的用户和权限
```yaml
services:
  app:
    user: "${UID}:${GID}"
    volumes:
      - ./data:/app/data:rw
```

## 🚨 紧急问题处理流程

### 系统完全无响应
```bash
# 1. 检查系统资源
htop
df -h

# 2. 检查服务状态
docker-compose ps

# 3. 查看服务日志
docker-compose logs --tail=100 backend

# 4. 重启问题服务
docker-compose restart backend

# 5. 如仍无响应，完全重启
docker-compose down
docker-compose up -d
```

### 数据库数据损坏
```bash
# 1. 立即停止写入
docker-compose stop backend rag-service

# 2. 备份当前数据
docker exec prism2-postgres pg_dump -U prism2 prism2 > backup_$(date +%Y%m%d_%H%M%S).sql

# 3. 检查数据库完整性
docker exec prism2-postgres vacuumdb -U prism2 --analyze --verbose prism2

# 4. 从备份恢复 (如需要)
docker exec -i prism2-postgres psql -U prism2 prism2 < backup_file.sql
```

---

**📅 创建时间**: 2025-09-18
**📊 问题覆盖率**: 基于实际开发中遇到的核心问题
**🔄 更新策略**: 遇到新问题立即更新此文档